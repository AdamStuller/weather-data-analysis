---
title: "Preprocessing"
output: html_document
---

```{r, include = FALSE}
source('setup.R')
```



```{r NA, echo = FALSE}

NA_values <- c("", '999', '9999', '99999', '999999', '+999', '+9999','+99999', '+999999', '009999')

process_col <- function(val, scaling = 1) {
  if (is.na(as.numeric(val)) || as.numeric(val) %in% NA_values){
    val <- NA
  }
  return (as.numeric(val)/scaling)
} 

```

## Loading of documents (years 1973 - 2020)

```{r setup}
#selected_cols <- c('STATION', 'DATE', 'TMP', 'WND_ANGLE', 'WND_SPEED', 'VIS', 'SLP', 'CIG', 'DEW', 'LATITUDE', 'LONGITUDE', 'ELEVATION','SNOW_DEPTH', 'PWO', 'NAME','GSO')


#allfiles <- list.files(path = "../data", pattern = "*.csv", full.names = T)
#data_sliac <- data.table::rbindlist(lapply(allfiles, function(x) cbind(fread(x, fill = T), gsub(".csv", "", x))), fill = T)
#data_sliac <- as.data.frame(data_sliac)
#View(data_sliac)

selected_cols <- c('STATION', 'DATE', 'TMP', 'WND_ANGLE', 'WND_SPEED', 'VIS', 'SLP', 'CIG', 'DEW','SNOW_DEPTH', 'PWO','GSO')

```

```{r}
read.csv(file= "../data/all_data.csv") %>% 
  dplyr::filter(STATION == 11903099999 | STATION == 11927599999 ) %>%
  dplyr::mutate(
      year = ymd_hms(DATE) %>% 
        lubridate::year() %>% 
        map_chr(~ as.character(.x))
    ) %>%
  dplyr::filter(year >= 1973 & year <2021) %>%
  separate(TMP, c('TMP', NA), sep=',')  %>% 
  separate(WND, c('WND_ANGLE', NA, NA, 'WND_SPEED', NA)) %>%
  separate(VIS, c('VIS', NA, NA, NA)) %>% 
  separate(SLP, c('SLP', NA)) %>% 
  separate(CIG, c('CIG', NA, NA, NA)) %>% 
  separate(DEW, c('DEW', NA), sep=',') %>% 
  separate(AJ1, c('SNOW_DEPTH', NA, NA, NA, NA, NA, NA)) %>%
  separate(AY1, c('PWO', NA, NA, NA)) %>% 
  separate(IA1, c('GSO', NA)) %>%
  dplyr::mutate(
    TMP = map_dbl(.$TMP,  process_col, 10),
    TMP = na_if(TMP, 999.9),
    WND_ANGLE = map_dbl(.$WND_ANGLE, process_col),
    WND_SPEED = map_dbl(.$WND_SPEED, process_col, 10),
    VIS = map_dbl(.$VIS, process_col),
    SLP = map_dbl(.$SLP, process_col, 10),
    CIG = map_dbl(.$CIG, process_col),
    DEW = map_dbl(.$DEW, process_col, 10),
    SNOW_DEPTH = map_dbl(.$SNOW_DEPTH, process_col),
    PWO = dplyr::na_if(PWO, ""),
    GSO = dplyr::na_if(GSO, "")
  ) %>%

  dplyr::select(all_of(selected_cols)) %>% 
  write.csv(file="../data/all.csv")

```




```{r}
all_data <- read.csv(file= "../data/all.csv")
View(all_data)

```


# Kruhovy graf G17

Dufal som ze to bude jednoduche ale exponencialne rozdelenie aj normalne aj to nase mi dava uplne presne kruhy, takze tak bude asi nejaka chyba... pockame, kum to Michal urobi pre erko. 

```{r}


n <- nrow(mandatory_data)
lo <- (n * (n - 1) / 2)^(-1 / 2)

Vx <- lo * cos(pi * mandatory_data$TMP)
Vy <- lo * sin(pi * mandatory_data$TMP)

ggplot(mapping=aes( x=Vx, y=Vy)) +
  geom_point() + 
  coord_fixed()
```
```{r}
normal_dist <- rnorm(-20:40, n = 2000) 

n <- length(normal_dist)
lo <- (n * (n - 1) / 2)^(-1 / 2)

Vx <- lo * cos(pi * normal_dist)
Vy <- lo * sin(pi * normal_dist)

ggplot(mapping=aes( x=Vx, y=Vy)) +
  geom_point() + 
  coord_fixed()

```
```{r}
exp_dist <- rexp(20000)

n <- length(exp_dist)
lo <- (n * (n - 1) / 2)^(-1 / 2)

e_Vx <- lo * cos(pi * exp_dist)
e_Vy <- lo * sin(pi * exp_dist)

ggplot(mapping=aes( x=e_Vx, y=e_Vy)) +
  geom_point() + 
  coord_fixed()
```



## EDA

Dáta obsahujú 413336 pozorovaní nameraných od januára 1973 do decembra 2020. V dátach sa nachádza 15 atribútov, z toho X označuje poradové číslo merania, STATION je id stanice Sliač a DATE predstavuje presný dátum a čas merania. Ostatné atribúty predstavujú hodnoty meraní pre teplotu, vietor, rosný bod a mnohé ďalšie. V dátach sa nachádzajú prevažne numerické spojité atribúty.

```{r}

str(all_data)
glimpse(all_data)

status(all_data) 
summary(all_data)

describe(all_data)

profiling_num(all_data) %>% select(variable, mean, std_dev, range_98)

```


Korelačná matica zobrazuje hodnoty korelácie medzi vybranými atribútmi - TMP, WND_ANGLE, WND_SPEED, VIS, SLP, CIG, DEW, SNOW_DEPTH, PWO, GSO, LP24. Hodnota (výberového) korelačného koeficientu sa pohybuje v intervale od -1 do 1. Ak je toto číslo kladné, vzťah medzi danými dvoma atribútmi je priamy, teda s narastajúcimi hodnotami X narastajú aj hodnoty Y. Ak je číslo záporné, tak medzi X a Y je vzťah nepriamy, čiže s narastajúcimi (klesajúcimi) hodnotami X klesajú (rastú) hodnoty Y. Ak je číslo rovné 0 tak neexistuje lineárna závislosť medzi X a Y, môže však existovať nelineárna závislosť. A teda čím bližšia hodnota k |1|, tým silnejší je vzťah medzi X a Y.

Najvyššia korelácia je medzi TMP a DEW (0.94), ide o kladnú koreláciu teda, čím vyššia je teplota tým vyššia je hodnota rosného bodu. Ďalej je dosť silná kladná korelácia aj medzi VIS a WND_SPEED.

Naopak záporná korelácia je medzi TMP a SLP, SLP a LP24.


```{r}
# korelacie vybranych numerickych atributov - TMP, WND_ANGLE, WND_SPEED, VIS, SLP, CIG, DEW
data_cor <- select(all_data, TMP, WND_ANGLE, WND_SPEED, VIS, SLP, CIG, DEW, SNOW_DEPTH, PWO, GSO, LP24)
cor <- cor(mdata_select, use = "na.or.complete")

corrplot.mixed(cor, lower="number", upper="circle", tl.pos = "lt", lower.col = "black",number.cex=0.75)

```



```{r}
pairs(~TMP + SLP+DEW+VIS+WND_SPEED+CIG+WND_ANGLE+ SLP, data=all_data)
```




```{r}
all_data_split_date <- mutate(
    all_data, 
    time = format(as_datetime(DATE), format = "%H:%M:%S"),
    date = format(as_date(DATE), format = "%Y-%m-%d"),
    month = month(DATE),
    year = year(DATE),
    md = substr(DATE, start = 6, stop = 10)
  )

data_temperature <- all_data_split_date %>% dplyr::select('DATE', 'TMP', 'time', 'date', 'year', 'month', 'md')
data_temperature <- data_temperature[!is.na(data_temperature$TMP), ]
data_temperature

```


```{r}
# priemerna denna teplota 
df_dayMean_tmp <- data_temperature %>% group_by(date) %>% summarise(tmp = na.omit(mean(TMP)), year = year, md = md)
df_dayMean_tmp <- unique(df_dayMean_tmp)
df_dayMean_tmp  


ggplot(df_dayMean_tmp, aes(x = as.Date(date), y = tmp)) +
  geom_line(color = "#4b9295") + 
  geom_smooth(color = 2) +
  labs(title = "Priemerné denné teploty: 1973 - 2020", x = "dátum", y = "teplota") +
  scale_x_date(date_breaks = "2 year", date_labels = "%Y") +
  theme(axis.text.x=element_text(angle=60, hjust=1)) +
  scale_y_continuous(breaks = seq(-30,30, by = 3))


table_dayMean_tmp <- data.table(year = df_dayMean_tmp$year, md = df_dayMean_tmp$md, tmp = df_dayMean_tmp$tmp)
table_dayMean_tmp

# vytvorenie tabulky 
# table_year_md_tmp <- dcast(table_dayMean_tmp, formula = year ~ md, value.var = 'tmp' ) # riadky = roky, stlpce = dni
table_year_md_tmp <- dcast(table_dayMean_tmp, formula = md ~ year, value.var = 'tmp' ) # riadky = dni, stlpce = roky
table_year_md_tmp

```

Z grafu priemerných denných teplôt pre roky 1973 - 2020 vidíme, že priemerná teplota sa časom mierne zvyšuje.



```{r}
# SOM mapa -> roky a dni
# vytvorenie matice
set.seed(123)
data_md_matrix <- as.matrix(table_year_md_tmp[,-1])
dim(data_md_matrix)

som_grid <- kohonen::somgrid(xdim = 4, ydim = 3, topo = "hexagonal")

som_model <- kohonen::som(X = data_md_matrix, grid = som_grid,
              rlen = 200, alpha = c(0.05,0.01), keep.data = T, dist.fcts = "euclidean", radius = 9)

plot(som_model, type="changes")

graphics::plot(som_model, type = "codes", shape = "straight")

som_model$unit.classif # zadelenie dni do tried
table(som_model$unit.classif)

som_model$grid
som_model$codes[[1]]

degrade.bleu <- function(n){
  return(rgb(0,0.4,1,alpha=seq(0,1,1/n)))
}

plot(som_model,type="count",palette.name=degrade.bleu)

```



```{r}
# priemerna mesacna teplota 
df_monthMean_tmp <- data_temperature %>% group_by(year,month) %>% summarise(tmp = na.omit(mean(TMP)), date = date)
df_monthMean_tmp

ggplot(df_monthMean_tmp, aes(x = as.Date(date), y = tmp)) +
  geom_line( color="#882545") + 
  geom_smooth(color = 4) +
  labs(title = "Priemerné mesačné teploty: 1973 - 2020", x = "dátum", y = "teplota") +
  scale_x_date(date_breaks = "2 year", date_labels = "%Y") +
  theme(axis.text.x=element_text(angle=60, hjust=1)) +
  scale_y_continuous(breaks = seq(-30,30, by = 3))


table_monthMean_tmp <- data.table(year = df_monthMean_tmp$year, month = df_monthMean_tmp$month, tmp = df_monthMean_tmp$tmp)
table_monthMean_tmp <- unique(table_monthMean_tmp)
table_monthMean_tmp

# vytvorenie tabulky 
table_year_month_tmp <- dcast(table_monthMean_tmp, formula = year ~ month, value.var = 'tmp' ) # riadky = roky, stlpce = dni
# table_year_month_tmp <- dcast(table_monthMean_tmp, formula = month ~ year, value.var = 'tmp' ) # riadky = dni, stlpce = roky
table_year_month_tmp

```


Graf zobrazuje priemerné mesačné teploty pre jednotlivé roky 1973 - 2020. Opäť aj tu je vidieť, že teplota sa zvyšuje.


```{r}
# matica
data_month_matrix <- as.matrix(table_year_month_tmp[,-1])
dim(data_month_matrix)

# HEATMAP
heatmap(data_month_matrix, 
        labRow = sort(table_year_month_tmp$year), 
        scale = 'none', 
        main = "Heatmap (teplota ~ mesiac ~ rok)", 
        col = colorRampPalette(c("#1d539f", "#408ab5" ,"#74ADD1", "#ABD9E9" ,"#E0F3F8" ,"#FFFFBF", "#feea90", "#fd9f68", "#a70146"))(25))


h <- stats::hclust(dist(data_month_matrix), method = "ward.D")
plot(h, labels = table_year_month_tmp$year, sub = "", xlab = "Years") 

```

Na základe heatmapy tiež vidíme rozdelenie rokov pod2a teploty. Najteplejší bol 7.mesiac a to v rokoch, ktoré majú tmavšiu bordovú farbu. Naopak najchladnejší bol januá, v rokoch, ktoré majú tmavšiu modrú farbu.


### Klastrovanie metódou SOM (Self-Organized Map)

V prvom kroku zvolíme rozmer a tvar SOM mapy. Zvolili sme mapu s rozmermi 3x2 polí, Euklidovskú metódu výpočtu vzdialenosti a tvar šesťuholníka, ktorý má viac susedov. Číslovanie polí je od 1 vľavo dole smerom doprava, najvyššie číslo má pole mapy vpravo hore.

Nastavenie ďalších parametrov súvisí s trénovaním SOM. Ak je parameter radius = 0 tak SOM je veľmi podobný K-Means algoritmu. Parameter radius by mal byť na začiatku cca 2/3 z rozmerov mapy - tu 3x2 = 6, čiže 4, postupne sa znižuje. Parameter rlen znamená koľkokrát sa dáta znovu načítajú a hodnotia v SOM. Tento parameter bol nastavený experimentálne sledovaním priebehu grafu “Changes”. Hodnoty v grafe by sa mali znižovať a nakoniec by už mali oscilovať okolo finálnej hodnoty. Vtedy už tento parameter netreba ďalej meniť.

```{r}
# SOM mapa -> roky a mesiace
set.seed(123)
som_grid <- kohonen::somgrid(xdim = 3, ydim = 2, topo = "hexagonal")

set.seed(123)
som_model <- kohonen::som(X = data_month_matrix, grid = som_grid,
              rlen = 200, alpha = c(0.05,0.01), keep.data = T, dist.fcts = "euclidean", radius = 4)

plot(som_model, type="changes")

graphics::plot(som_model, type = "codes", shape = "straight")

som_model$unit.classif # zadelenie rokov do tried
table(som_model$unit.classif) # pocty v triedach


df <- data.frame(year = c(1973:2020), class = som_model$unit.classif)
df[order(df$class),]

df_1 <- merge(x = df %>% filter(class == 1), y = df_monthMean_tmp, by = "year", all = F)
df_1 <- unique(df_1) %>% group_by(year) %>% summarise(mean_tmp = mean(tmp))
mean_tmp_1 <- mean(df_1$mean_tmp)


df_2 <- merge(x = df %>% filter(class == 2), y = df_monthMean_tmp, by = "year", all = F)
df_2 <- unique(df_2) %>% group_by(year) %>% summarise(mean_tmp = mean(tmp))
mean_tmp_2 <- mean(df_2$mean_tmp)

df_3 <- merge(x = df %>% filter(class == 3), y = df_monthMean_tmp, by = "year", all = F)
df_3 <- unique(df_3) %>% group_by(year) %>% summarise(mean_tmp = mean(tmp))
mean_tmp_3 <- mean(df_3$mean_tmp)


df_4 <- merge(x = df %>% filter(class == 4), y = df_monthMean_tmp, by = "year", all = F)
df_4 <- unique(df_4) %>% group_by(year) %>% summarise(mean_tmp = mean(tmp))
mean_tmp_4 <- mean(df_4$mean_tmp)


df_5 <- merge(x = df %>% filter(class == 5), y = df_monthMean_tmp, by = "year", all = F)
df_5 <- unique(df_5) %>% group_by(year) %>% summarise(mean_tmp = mean(tmp))
mean_tmp_5 <- mean(df_5$mean_tmp)

df_6 <- merge(x = df %>% filter(class == 6), y = df_monthMean_tmp, by = "year", all = F)
df_6 <- unique(df_6) %>% group_by(year) %>% summarise(mean_tmp = mean(tmp))
mean_tmp_6 <- mean(df_6$mean_tmp)

tmp_class <- data.frame(class = c(1:6), mean_tmp = c(mean_tmp_1,mean_tmp_2,mean_tmp_3,mean_tmp_4,mean_tmp_5,mean_tmp_6))
tmp_class

ggplot(tmp_class, aes(x = class, y = mean_tmp, fill = as.factor(class))) +
  geom_bar(stat = "identity") +
  labs(title = "Priemerné teploty v triedach", x = "Trieda", y = "Teplota") +
  theme(legend.position="none") +
  geom_text(mapping = aes(label = round(mean_tmp,2)), vjust = -0.5, size = 4) +
  scale_y_continuous(breaks = seq(0, 12, by = 1)) +
  scale_x_continuous(breaks = seq(1,6, by = 1)) 
  

ggplot(df, aes(x = year, y = class)) +
  geom_point(aes(color = as.factor(class)), size = 2) +
  scale_y_continuous(breaks = seq(1,6, by = 1)) +
  labs(title = "Roky v triedach", x = "Rok", y = "Trieda") +
  scale_x_continuous(breaks = seq(1973, 2020, by = 1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(legend.position="none")

```

Na základe klastrovania pomocou SOM mapy sme zadelili jednotlivé roky do 6 tried podľa ich priemerných mesačných teplôt. Ako vidieť z grafov 6. trieda obsahuje väčšinu súčasných rokov nad 2010 a priemerná teplota v tejto triede je najvyššia, čo svedčí o tom, že v posledných rokoch sa teplota zvyšuje. Naopak tried č.1 obsahuje väčšinu 70-tych rokov a priemerná teplota rokov patriacich do tejto triedy je najnižšia. 




```{r}
# Predikcia na 1 rok
set.seed(123)
df_monthMean_tmp <- df_monthMean_tmp %>% dplyr::select(year,month,tmp)
df_monthMean_tmp <- unique(df_monthMean_tmp)

data_ts <- ts(df_monthMean_tmp$tmp, start = c(1973, 1), end = c(2020, 12), frequency = 12)
data_ts

arima_model <- forecast::auto.arima(data_ts)
summary(arima_model)
fore_arima = forecast::forecast(arima_model, h = 12)
df_arima = as.data.frame(fore_arima)
df_arima

```

```{r}
library(fpp3)



tmpts <- data_temperature %>%
  dplyr::mutate(
    year_month = yearmonth(paste(year, month))
  ) %>%
  dplyr::group_by(year_month) %>%
  dplyr::summarise(tmp = na.omit(mean(TMP))) %>%
  as_tsibble(
    index = year_month
    ) 


tmpts %>%
  model(
    ets = ETS(box_cox(tmp, 0.3)),
    arima = ARIMA(log(tmp)),
    snaive = SNAIVE(tmp)
  ) %>%
  forecast(h = "2 years") %>% 
  autoplot(filter(tmpts, year(year_month) > 2010), level = NULL)
```


```{r}
df_dayMean_tmp <- data_temperature %>% group_by(date) %>% summarise(tmp = na.omit(mean(TMP)), date = date)
df_dayMean_tmp <- unique(df_dayMean_tmp)
df_dayMean_tmp$date_ts <- c(1:length(df_dayMean_tmp$date))
df_dayMean_tmp

# time series LM 
lm_ts <- lm(formula = tmp ~ date_ts, data = df_dayMean_tmp)
lm_ts$coefficients


attach(df_dayMean_tmp)

pairs( ~ date_ts + tmp, panel = function(x,y){
  points(x,y)
  abline(lm(y~x), col = 2)})

```


```{r}
# zrazky a tmp linearna regresia
df_dayMean_tmp <- data_temperature %>% group_by(date) %>% summarise(tmp = na.omit(mean(TMP)), date = date)
df_dayMean_tmp <- unique(df_dayMean_tmp)
df_dayMean_tmp


data_lp <- all_data_split_date %>% dplyr::select('DATE', 'LP', 'time', 'date', 'year', 'month', 'md')
data_lp <- data_lp[!is.na(data_lp$LP), ] %>% separate(LP, c('LPtime', 'LP', NA, NA), sep=',') 
data_lp$LP <- as.double(data_lp$LP)
data_lp <-  data_lp %>% dplyr::mutate(LP = map_dbl(.$LP, process_col, 10))
data_lp <- data_lp[!is.na(data_lp$LP), ]
data_lp

df_dayMean_lp <- data_lp %>% dplyr::group_by(date) %>% summarise(lp = na.omit(mean(LP)), date = date)
df_dayMean_lp <- unique(df_dayMean_lp)
df_dayMean_lp


df_tmp_lp <- merge(x = df_dayMean_lp, y = df_dayMean_tmp, by = "date", all.y = T) 
df_tmp_lp$lp[is.na(df_tmp_lp$lp)] <- 0 # ak niekde chyba hodnota LP, LP = 0
df_tmp_lp

ggplot(df_tmp_lp, aes(x = as.Date(date), y = lp)) +
  geom_line( color="#882545") + 
  geom_smooth(color = 4) +
  labs(title = "Priemerné mesačné teploty: 1973 - 2020", x = "dátum", y = "teplota") +
  scale_x_date(date_breaks = "2 year", date_labels = "%Y") +
  theme(axis.text.x=element_text(angle=60, hjust=1)) +
  scale_y_continuous(breaks = seq(0,1, by = 0.05))

# linearna regresia
# Hypoteza: Rocna teplota rastie a s nou rastie aj mnozstvo zrazok
normalize <- function(x) {
  return ((x - min(x)) / (max(x) - min(x)))
}
df_tmp_lp$lp <- normalize(df_tmp_lp$lp)
df_tmp_lp$tmp <- normalize(df_tmp_lp$tmp)
df_tmp_lp

attach(df_tmp_lp)


tmp_lp_model <- lm(formula = lp ~ tmp, data = df_tmp_lp)
summary(tmp_lp_model)

pairs( ~ tmp + lp, panel = function(x,y){
  points(x,y)
  abline(lm(y~x), col = 2)})


```



